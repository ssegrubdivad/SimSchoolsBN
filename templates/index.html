<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bayesian Network API</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
/*        For general layout*/
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        body {
            font-family: -apple-system,system-ui,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
            font-weight: 100;
            color: black;
            background-color: white;
            padding: 5vh 15vw;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .headline {
            border: #3492eb 0.35vmin solid;
            border-radius: 2vmin;
            padding: 2vmin 3vmin 3vmin 3vmin;
            text-align: center;
            font-size: 6vmin;
            box-shadow: rgba(17, 17, 26, 0.05) 0px 1px 0px, rgba(17, 17, 26, 0.1) 0px 0px 8px;
        }
        .heavy {
            font-weight: 600;
        }
        .info {
            border: #3492eb 0.35vmin solid;
            border-radius: 2vmin;
            padding: 2vmin 3vmin 3vmin 3vmin;
            width: 100%;
            margin-bottom: 2vh;
            box-sizing: border-box;
        }
        input, button {
            margin: 0 0 2vh 0;
/*            font-family: 'Courier New', monospace;
            font-weight: 600;
            font-size: 1.5vmin; */
        }
        .title {
            font-weight: 800;
            font-size: 4vmin;
            padding-bottom: 3vmin;
            padding-left: 1vmin;
            display: inline-block;
        }
        #token {
            max-width: 100%;
            width: 100%;
            height: 10vmin;
            font-family: 'Courier New', monospace;
            max-height: 20vmin;
            font-size: 1.5vmin;
            background-color: #FFFFFF;
            color: black;
        }

/*        For the networkVisualization svg element*/
        .links line {
            stroke: #999;
            stroke-opacity: 1;
        }
        .nodes circle {
            stroke: #fff;
            stroke-width: 2px;
            cursor: move;
        }
        .labels text {
            font-family: sans-serif;
            font-size: 12px;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and IE 11 */
            user-select: none;
            cursor: default;
        }
        #networkVisualization {
            border: 1px solid #ccc;
            margin-top: 10px;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: default;
            width: 100%;
            height: 60vh; 
            min-height: 300px; 
            position: relative; 
        }

        #networkVisualization svg {
            position: absolute; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

/*        Additional network visualization elements*/
        .visualization-controls {
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .control-options {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .control-legend {
            margin: 1rem 0;
            padding: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0.5rem 0;
        }

        .color-box {
            width: 20px;
            height: 20px;
            margin-right: 0.5rem;
            border-radius: 4px;
        }

        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .nodes circle {
            stroke-width: 2px;
            cursor: pointer;
        }

        .nodes circle.requires-coordination {
            stroke-dasharray: 5,5;
        }

        .influence-path {
            stroke-opacity: 0.3;
            stroke-width: 5px;
            pointer-events: none;
        }

        .authority-path {
            stroke: #FF4081;
            stroke-width: 3px;
            stroke-dasharray: 5,5;
        }

        .node-label {
            font-size: 12px;
            pointer-events: none;
        }

        .tooltip {
            position: absolute;
            padding: 8px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
        }

/*        For the query results*/
        #queryVisualization {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .visualization-controls {
            margin-bottom: 20px;
        }

        #variableSelect {
            margin-left: 10px;
        }

        #visualizationContainer svg {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="content-wrapper">
        <div class="title">Welcome to the Bayesian Network API</div><br />
        
        <div class="debug-box" style="display: none;">
            <p>Debug Info: If you can see this box, the content is being rendered correctly.</p>
            <p>Viewport Height: <span id="viewport-height"></span></p>
            <p>Document Height: <span id="document-height"></span></p>
        </div>

        <form id="loginForm" onsubmit="login(event)">
            <div class="info">
                <h2>Login</h2>
                <input type="text" id="username" placeholder="Username" required /><br />
                <input type="password" id="password" placeholder="Password" required /><br />
                <button type="submit">Login</button>
            </div>
        </form>
        
        <div id="apiInfo" style="display: none;">
            <div class="info">
                <h2>API Endpoints</h2>
                <p>Use the following endpoints:</p>
                <ul>
                    <li><code>/upload_network</code> (POST): Upload a new Bayesian Network</li>
                    <li><code>/upload_cpt</code> (POST): Upload a CPT file</li>
                    <li><code>/query</code> (POST): Query the Bayesian Network</li>
                </ul>
                <p>Token:<br><textarea id="token"></textarea></p>
            </div>
            
            <div class="info">
                <h2>Upload Bayesian Network</h2>
                <form id="uploadNetworkForm">
                    <input type="file" id="networkFile" accept=".bns" required="">
                    <button type="submit">Upload Network</button>
                </form>
            </div>
            
            <div class="info">
                <h2>Upload CPT</h2>
                <form id="uploadCPTForm">
                    <input type="file" id="cptFile" accept=".cpt" required="">
                    <button type="submit">Upload CPT</button>
                </form>
            </div>

            <div class="info">
                <h2>Visualize Network</h2>
                <div class="visualization-controls">
                    <button id="visualizeNetworkBtn" onclick="visualizeNetwork()">Visualize Network</button>
                    <div class="control-options">
                        <label>
                            <input type="checkbox" id="showControlLevels" checked>
                            Show Control Levels
                        </label>
                        <label>
                            <input type="checkbox" id="showInfluencePaths" checked>
                            Show Influence Paths
                        </label>
                        <select id="highlightControlLevel">
                            <option value="">Highlight Authority Path...</option>
                            <option value="STUDENT">Student Level</option>
                            <option value="TEACHER">Teacher Level</option>
                            <option value="PARENT">Parent Level</option>
                            <option value="SCHOOL_ADMIN">School Admin Level</option>
                            <option value="DISTRICT_ADMIN">District Admin Level</option>
                        </select>
                    </div>
                </div>
                <div id="controlLegend" class="control-legend">
                    <h3>Control Levels</h3>
                    <div class="legend-item">
                        <span class="color-box" style="background-color: #4CAF50;"></span>
                        <span>Student</span>
                    </div>
                    <div class="legend-item">
                        <span class="color-box" style="background-color: #2196F3;"></span>
                        <span>Teacher</span>
                    </div>
                    <div class="legend-item">
                        <span class="color-box" style="background-color: #FFC107;"></span>
                        <span>Parent</span>
                    </div>
                    <div class="legend-item">
                        <span class="color-box" style="background-color: #9C27B0;"></span>
                        <span>School Admin</span>
                    </div>
                    <div class="legend-item">
                        <span class="color-box" style="background-color: #F44336;"></span>
                        <span>District Admin</span>
                    </div>
                </div>
                <div id="networkVisualization"></div>
            </div>

            <div class="info">
                <h2>Query Network</h2>
                <form id="queryForm">
                    <select id="queryType">
                        <option value="marginal">Marginal</option>
                        <option value="conditional">Conditional</option>
                        <option value="interventional">Interventional</option>
                        <option value="map">MAP</option>
                        <option value="mpe">MPE</option>
                        <option value="temporal">Temporal</option>
                    </select>
                    <select id="inferenceAlgorithm">
                        <option value="variable_elimination">Variable Elimination</option>
                        <option value="junction_tree">Junction Tree</option>
                    </select>
                    <input type="text" id="queryVars" placeholder="Query variables (comma-separated)">
                    <input type="text" id="evidence" placeholder="Evidence (JSON format)">
                    <input type="text" id="interventions" placeholder="Interventions (JSON format)">
                    <input type="number" id="timeSteps" placeholder="Time steps (for temporal queries)" style="display: none;">
                    <button type="submit">Query</button>
                </form>
                <div id="queryResult"></div>
                <div id="queryVisualization" style="display: none;">
                    <div class="visualization-controls">
                        <label for="variableSelect">Select Variable:</label>
                        <select id="variableSelect" class="border rounded p-1"></select>
                    </div>
                    <div id="visualizationContainer" style="height: 400px; width: 100%; margin-top: 20px;"></div>
                </div>
            </div>
        </div>

    <script>
        let apiToken = '';
        const apiBaseUrl = ''; // Use relative URL

        // Debug info update
        function updateDebugInfo() {
            document.getElementById('viewport-height').textContent = window.innerHeight + 'px';
            document.getElementById('document-height').textContent = document.documentElement.scrollHeight + 'px';
        }

        window.addEventListener('load', updateDebugInfo);
        window.addEventListener('resize', updateDebugInfo);

        async function login(event) {
            event.preventDefault(); // Prevent default form submission
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            try {
                const response = await axios.post('/login', { username, password });
                apiToken = response.data.token;
                document.getElementById('token').textContent = apiToken;
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('apiInfo').style.display = 'block';
                updateDebugInfo(); // Update debug info after showing new content
            } catch (error) {
                alert('Login failed');
                console.error('Login error:', error);
            }
        }

        async function uploadNetwork(event) {
            event.preventDefault();
            const fileInput = document.getElementById('networkFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('Please select a file');
                return;
            }
            const formData = new FormData();
            formData.append('file', file);
            try {
                const response = await axios.post('/upload_network', formData, {
                    headers: { 
                        'Authorization': 'Bearer ' + apiToken,
                        'Content-Type': 'multipart/form-data'
                    }
                });
                console.log(response.data);
                
                if (response.data.status === 'warning') {
                    if (response.data.validation_errors.includes('no probability distribution specified')) {
                        alert(
                            'Network structure successfully uploaded!\n\n' +
                            'Next step: Please upload a CPT (Conditional Probability Table) file to specify ' +
                            'probability distributions for the network nodes.'
                        );
                    } else {
                        alert(
                            'Network uploaded but has validation issues:\n\n' + 
                            response.data.validation_errors
                        );
                    }
                } else if (response.data.status === 'success') {
                    alert('Network uploaded and validated successfully');
                }
            } catch (error) {
                console.error('Error uploading network:', error);
                alert('Error uploading network: ' + (error.response?.data?.message || error.message));
            }
        }

        async function uploadCPT(event) {
            event.preventDefault();
            const fileInput = document.getElementById('cptFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('Please select a file');
                return;
            }
            const formData = new FormData();
            formData.append('file', file);
            try {
                const response = await axios.post('/upload_cpt', formData, {
                    headers: { 
                        'Authorization': 'Bearer ' + apiToken,
                        'Content-Type': 'multipart/form-data'
                    }
                });
                console.log(response.data);
                
                if (response.data.status === 'warning') {
                    let warningMessage = 'CPTs uploaded but have validation issues:\n\n';
                    
                    // Group similar errors together
                    const errors = response.data.validation_errors.split('\n');
                    const missingParams = errors.filter(e => e.includes('missing required parameter'));
                    const distributionErrors = errors.filter(e => e.includes('CLGDistribution'));
                    const otherErrors = errors.filter(e => !e.includes('missing required parameter') && !e.includes('CLGDistribution'));
                    
                    // Format missing parameters more clearly
                    if (missingParams.length > 0) {
                        const node = missingParams[0].split('Node ')[1].split(' missing')[0];
                        warningMessage += `${node} is missing required parameters:\n`;
                        missingParams.forEach(error => {
                            const param = error.split('parameter: ')[1];
                            warningMessage += `  • ${param}\n`;
                        });
                        warningMessage += '\n';
                    }
                    
                    // Format distribution type errors
                    if (distributionErrors.length > 0) {
                        warningMessage += 'Distribution type validation errors:\n';
                        distributionErrors.forEach(error => {
                            const node = error.split('node ')[1].split(':')[0];
                            warningMessage += `  • ${node}: Invalid distribution configuration\n`;
                        });
                        warningMessage += '\n';
                    }
                    
                    // Add any other errors
                    if (otherErrors.length > 0) {
                        warningMessage += 'Additional validation issues:\n';
                        otherErrors.forEach(error => {
                            warningMessage += `  • ${error.trim()}\n`;
                        });
                    }
                    
                    alert(warningMessage);
                } else if (response.data.status === 'success') {
                    alert('CPTs uploaded and validated successfully');
                }
            } catch (error) {
                console.error('Error uploading CPT:', error);
                let errorMessage = 'Error uploading CPT file.';
                if (error.response?.data) {
                    errorMessage += ' ' + error.response.data.message;
                    if (error.response.data.details) {
                        errorMessage += '\n\nDetails:\n' + error.response.data.details;
                    }
                }
                alert(errorMessage);
            }
        }

        async function queryNetwork(queryData) {
            try {
                const response = await axios.post('/query', queryData, {
                    headers: { 'Authorization': 'Bearer ' + apiToken }
                });
                console.log(response.data);
            } catch (error) {
                console.error('Error querying network:', error);
            }
        }

        async function visualizeNetwork() {
            try {
                const response = await axios.get('/visualize_network', {
                    headers: { 'Authorization': 'Bearer ' + apiToken },
                    responseType: 'json'
                });
                
                const visualizationDiv = document.getElementById('networkVisualization');
                visualizationDiv.innerHTML = '';
                
                // Create SVG
                const width = visualizationDiv.clientWidth;
                const height = visualizationDiv.clientHeight || 600;
                
                const svg = d3.select(visualizationDiv)
                    .append("svg")
                    .attr("viewBox", `0 0 ${width} ${height}`)
                    .attr("preserveAspectRatio", "xMidYMid meet");

                // Create tooltip
                const tooltip = d3.select(visualizationDiv)
                    .append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0);

                const graph = response.data;

                const colorScheme1 = [
                    "#0068da", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896",
                    "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7",
                    "#bcbd22", "#dbdb8d", "#17becf", "#9edae5", "#393b79", "#637939", "#8c6d31", "#843c39", 
                    "#7b4173", "#636363"
                ];

                const color = d3.scaleOrdinal(colorScheme1);

                // State management
                const state = {
                    selectedNode: null,
                    activeFilter: 'ALL',
                    analysisMode: false,
                    highlightedPath: null,
                    relationshipMode: false,
                    selectedLevel: null
                };

                // Initialize force simulation
                const simulation = d3.forceSimulation(graph.nodes)
                    .force("link", d3.forceLink(graph.links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(30));

                // Create arrow marker
                svg.append("defs").selectAll("marker")
                    .data(["standard", "influence", "authority"])
                    .enter().append("marker")
                    .attr("id", d => `arrow-${d}`)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 20)
                    .attr("refY", 0)
                    .attr("markerWidth", 8)
                    .attr("markerHeight", 8)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", d => d === "influence" ? "#2196F3" : 
                                      d === "authority" ? "#FF4081" : "#999");

                // Create containers for different layers
                const layers = {
                    influencePaths: svg.append("g").attr("class", "influence-paths"),
                    links: svg.append("g").attr("class", "links"),
                    nodes: svg.append("g").attr("class", "nodes"),
                    labels: svg.append("g").attr("class", "labels"),
                    highlights: svg.append("g").attr("class", "highlights"),
                    overlay: svg.append("g").attr("class", "overlay")
                };

                // Create links
                const link = layers.links.selectAll("line")
                    .data(graph.links)
                    .enter().append("line")
                    .attr("stroke-width", d => d.strokeWidth || 1)
                    .attr("stroke-dasharray", d => d.strokeDasharray)
                    .attr("marker-end", "url(#arrow-standard)")
                    .style("stroke", "#999");

                // Create nodes
                const node = layers.nodes.selectAll("circle")
                    .data(graph.nodes)
                    .enter().append("circle")
                    .attr("r", 15)
                    .attr("fill", d => color(d.id))
                    .classed("requires-coordination", d => d.requiresCoordination)
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended));

                // Create labels
                const label = layers.labels.selectAll("text")
                    .data(graph.nodes)
                    .enter().append("text")
                    .attr("class", "node-label")
                    .text(d => d.id)
                    .attr("x", 20)
                    .attr("y", 4);

                // Visualization Manager
                const visualizationManager = {
                    // Filter Management
                    filterByControlLevel(level) {
                        state.activeFilter = level;
                        
                        d3.selectAll('.filter-btn')
                            .classed('active', d => d3.select(d).attr('data-level') === level);

                        const baseOpacity = level === 'ALL' ? 1 : 0.2;
                        
                        node.transition().duration(300)
                            .style('opacity', d => level === 'ALL' || d.controlLevel === level ? 1 : baseOpacity);

                        link.transition().duration(300)
                            .style('opacity', d => {
                                if (level === 'ALL') return 0.6;
                                return (d.source.controlLevel === level || 
                                        d.target.controlLevel === level) ? 0.6 : 0.1;
                            });

                        this.updateInfluencePaths(level);
                    },

                    // Influence Analysis
                    showInfluenceAnalysis(nodeId) {
                        if (!nodeId) return;
                        
                        const selectedNode = graph.nodes.find(n => n.id === nodeId);
                        state.analysisMode = true;
                        state.selectedNode = selectedNode;

                        // Calculate metrics
                        const metrics = this.calculateInfluenceMetrics(selectedNode);
                        
                        // Update display
                        d3.select('#influenceMetrics')
                            .style('display', 'block')
                            .transition()
                            .duration(300)
                            .style('opacity', 1);

                        d3.select('#directInfluence').text(metrics.direct.toFixed(2));
                        d3.select('#indirectInfluence').text(metrics.indirect.toFixed(2));

                        // Highlight influence paths
                        this.highlightInfluencePaths(selectedNode);
                    },

                    calculateInfluenceMetrics(node) {
                        const metrics = {
                            direct: 0,
                            indirect: 0
                        };

                        // Calculate direct influence
                        const directConnections = graph.links.filter(
                            l => l.source.id === node.id || l.target.id === node.id
                        );
                        
                        metrics.direct = directConnections.reduce((sum, link) => {
                            return sum + this.getInfluenceWeight(
                                link.source.id === node.id ? link.source : link.target,
                                link.source.id === node.id ? link.target : link.source
                            );
                        }, 0);

                        // Calculate indirect influence
                        const indirectPaths = this.findIndirectPaths(node);
                        metrics.indirect = indirectPaths.reduce((sum, path) => {
                            return sum + this.calculatePathStrength(path);
                        }, 0);

                        return metrics;
                    },

                    getInfluenceWeight(source, target) {
                        if (!source.controlLevel || !target.controlLevel) return 0;
                        
                        const sourceLevelValue = ControlLevel[source.controlLevel];
                        const targetLevelValue = ControlLevel[target.controlLevel];
                        
                        const baseWeight = source.influenceWeight || 1;
                        const levelDifference = Math.abs(sourceLevelValue - targetLevelValue);
                        
                        return baseWeight * Math.pow(0.8, levelDifference);
                    },

                    // Path Building and Analysis
                    buildAuthorityPath(startLevel, endLevel) {
                        this.clearHighlights();
                        
                        const paths = this.findAuthorityPaths(startLevel, endLevel);
                        if (!paths.length) {
                            alert('No valid authority path found');
                            return;
                        }

                        const optimalPath = this.selectOptimalPath(paths);
                        this.highlightAuthorityPath(optimalPath);
                        this.showPathMetrics(optimalPath);
                    },

                    findAuthorityPaths(startLevel, endLevel) {
                        const paths = [];
                        const visited = new Set();

                        const dfs = (currentLevel, currentPath) => {
                            if (currentLevel === endLevel) {
                                paths.push([...currentPath]);
                                return;
                            }

                            visited.add(currentLevel);
                            const nextLevels = this.getValidNextLevels(currentLevel);
                            
                            for (const nextLevel of nextLevels) {
                                if (!visited.has(nextLevel)) {
                                    currentPath.push(nextLevel);
                                    dfs(nextLevel, currentPath);
                                    currentPath.pop();
                                }
                            }
                            visited.delete(currentLevel);
                        };

                        dfs(startLevel, [startLevel]);
                        return paths;
                    },

                    getValidNextLevels(currentLevel) {
                        // Define valid transitions between levels
                        const validTransitions = {
                            'STUDENT': ['TEACHER'],
                            'TEACHER': ['SCHOOL_ADMIN'],
                            'PARENT': ['TEACHER', 'SCHOOL_ADMIN'],
                            'SCHOOL_ADMIN': ['DISTRICT_ADMIN'],
                            'DISTRICT_ADMIN': []
                        };

                        return validTransitions[currentLevel] || [];
                    },

                    selectOptimalPath(paths) {
                        return paths.reduce((best, current) => {
                            const currentStrength = this.calculatePathStrength(current);
                            const bestStrength = this.calculatePathStrength(best);
                            return currentStrength > bestStrength ? current : best;
                        });
                    },

                    calculatePathStrength(path) {
                        let strength = 1.0;
                        for (let i = 0; i < path.length - 1; i++) {
                            const sourceNode = this.findNodeByLevel(path[i]);
                            const targetNode = this.findNodeByLevel(path[i + 1]);
                            if (sourceNode && targetNode) {
                                strength *= this.getInfluenceWeight(sourceNode, targetNode);
                            }
                        }
                        return strength;
                    },

                    // Relationship Exploration
                    exploreRelationships(nodeId) {
                        const node = graph.nodes.find(n => n.id === nodeId);
                        if (!node) return;

                        this.clearRelationshipExploration();
                        state.relationshipMode = true;

                        const relationships = {
                            upstream: this.findUpstreamRelationships(node),
                            downstream: this.findDownstreamRelationships(node),
                            coordination: this.findCoordinationRelationships(node)
                        };

                        this.visualizeRelationships(relationships);
                    },

                    findUpstreamRelationships(node) {
                        return graph.links.filter(l => l.target.id === node.id)
                            .map(l => ({
                                source: l.source,
                                target: l.target,
                                type: 'upstream'
                            }));
                    },

                    findDownstreamRelationships(node) {
                        return graph.links.filter(l => l.source.id === node.id)
                            .map(l => ({
                                source: l.source,
                                target: l.target,
                                type: 'downstream'
                            }));
                    },

                    findCoordinationRelationships(node) {
                        if (!node.requiresCoordination) return [];
                        
                        return graph.nodes
                            .filter(n => n.controlLevel && 
                                       node.secondaryLevels?.includes(n.controlLevel))
                            .map(n => ({
                                source: node,
                                target: n,
                                type: 'coordination'
                            }));
                    },

                    // Visualization Helpers
                    clearHighlights() {
                        layers.highlights.selectAll("*").remove();
                        node.classed("selected-node", false);
                        link.attr("marker-end", "url(#arrow-standard)")
                            .style("stroke", "#999");
                    },

                    clearRelationshipExploration() {
                        layers.overlay.selectAll("*").remove();
                        state.relationshipMode = false;
                    },

                    updateInfluencePaths(level) {
                        if (!graph.influencePaths) return;

                        const relevantPaths = level === 'ALL' ? 
                            graph.influencePaths :
                            graph.influencePaths.filter(p => 
                                p.source.controlLevel === level || 
                                p.target.controlLevel === level
                            );

                        const paths = layers.influencePaths.selectAll("path")
                            .data(relevantPaths, d => `${d.source.id}-${d.target.id}`);

                        paths.exit().remove();

                        paths.enter()
                            .append("path")
                            .merge(paths)
                            .attr("class", "influence-path")
                            .attr("stroke", d => d3.interpolateBlues(d.strength))
                            .attr("d", d => this.calculatePath(d.source, d.target));
                    },

                    calculatePath(source, target) {
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        return `M${source.x},${source.y}A${dr},${dr} 0 0,1 ${target.x},${target.y}`;
                    }
                };

                // Event Handlers
                node.on("click", function(event, d) {
                    event.stopPropagation();
                    state.selectedNode = state.selectedNode === d ? null : d;
                    
                    node.classed("selected-node", n => n === state.selectedNode);
                    
                    if (state.selectedNode) {
                        visualizationManager.exploreRelationships(d.id);
                        if (state.analysisMode) {
                            visualizationManager.showInfluenceAnalysis(d.id);
                        }
                    } else {
                        visualizationManager.clearHighlights();
                        visualizationManager.clearRelationshipExploration();
                    }
                })
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    
                    const content = `
                        <strong>${d.id}</strong><br/>
                        Control Level: ${d.controlLevel || 'N/A'}<br/>
                        ${d.influenceWeight ? `Influence: ${d.influenceWeight.toFixed(2)}<br/>` : ''}
                        ${d.requiresCoordination ? 'Requires Coordination<br/>' : ''}
                        ${d.secondaryLevels?.length ? 
                            `Secondary Levels: ${d.secondaryLevels.join(', ')}` : ''}
                    `;
                    
                    tooltip.html(content)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

                // Simulation tick handler
                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    label
                        .attr("x", d => d.x + 20)
                        .attr("y", d => d.y + 4);

                    layers.influencePaths.selectAll("path")
                        .attr("d", d => visualizationManager.calculatePath(d.source, d.target));
                });

                // Drag handlers
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }

                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }

                // Control button handlers
                d3.selectAll('.filter-btn').on('click', function() {
                    const level = d3.select(this).attr('data-level');
                    visualizationManager.filterByControlLevel(level);
                });

                d3.select('#showInfluenceAnalysis').on('click', () => {
                    if (state.selectedNode) {
                        visualizationManager.showInfluenceAnalysis(state.selectedNode.id);
                    } else {
                        alert('Please select a node first');
                    }
                });

                d3.select('#showPath').on('click', () => {
                    const startLevel = d3.select('#startLevel').property('value');
                    const endLevel = d3.select('#endLevel').property('value');
                    
                    if (startLevel && endLevel) {
                        visualizationManager.buildAuthorityPath(startLevel, endLevel);
                    } else {
                        alert('Please select both start and end levels');
                    }
                });

                // Window resize handler
                function handleResize() {
                    const width = visualizationDiv.clientWidth;
                    const height = visualizationDiv.clientHeight || 600;
                    
                    svg.attr("viewBox", `0 0 ${width} ${height}`);
                    simulation.force("center", d3.forceCenter(width / 2, height / 2));
                    simulation.alpha(0.3).restart();
                }

                window.addEventListener('resize', handleResize);

                // Initial setup
                visualizationManager.filterByControlLevel('ALL');
                
                // Cleanup on unmount
                return () => {
                    window.removeEventListener('resize', handleResize);
                    simulation.stop();
                };

            } catch (error) {
                console.error('Error visualizing network:', error);
                alert('Error visualizing network');
            }
        }

        function visualizeQueryResult(queryResult, queryType) {
            const visualizationDiv = document.getElementById('queryVisualization');
            const variableSelect = document.getElementById('variableSelect');
            const container = document.getElementById('visualizationContainer');
            
            visualizationDiv.style.display = 'block';
            container.innerHTML = ''; // Clear previous visualization

            // Get variables from query result
            const variables = Object.keys(queryResult.result || {});
            
            // Update variable selection dropdown
            variableSelect.innerHTML = variables
                .map(v => `<option value="${v}">${v}</option>`)
                .join('');

            function createVisualization(variable) {
                container.innerHTML = ''; // Clear container
                
                const data = queryResult.result[variable];
                
                // Determine if the data is an array (discrete distribution) or object (continuous/temporal)
                const isDiscrete = Array.isArray(data);
                
                const width = container.clientWidth;
                const height = container.clientHeight;
                const margin = { top: 40, right: 40, bottom: 60, left: 60 };
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
                    
                const chart = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                    
                const chartWidth = width - margin.left - margin.right;
                const chartHeight = height - margin.top - margin.bottom;

                if (isDiscrete) {
                    // Create bar chart for discrete variables
                    const x = d3.scaleBand()
                        .range([0, chartWidth])
                        .padding(0.1);

                    const y = d3.scaleLinear()
                        .range([chartHeight, 0]);

                    // Format data for bar chart
                    const barData = data.map((value, index) => ({
                        state: `State ${index + 1}`,
                        probability: value
                    }));

                    x.domain(barData.map(d => d.state));
                    y.domain([0, 1]); // Probabilities are always between 0 and 1

                    // Add X axis
                    chart.append('g')
                        .attr('transform', `translate(0,${chartHeight})`)
                        .call(d3.axisBottom(x))
                        .selectAll('text')
                        .style('text-anchor', 'end')
                        .attr('dx', '-.8em')
                        .attr('dy', '.15em')
                        .attr('transform', 'rotate(-45)');

                    // Add Y axis
                    chart.append('g')
                        .call(d3.axisLeft(y));

                    // Add bars
                    chart.selectAll('rect')
                        .data(barData)
                        .enter()
                        .append('rect')
                        .attr('x', d => x(d.state))
                        .attr('width', x.bandwidth())
                        .attr('y', d => y(d.probability))
                        .attr('height', d => chartHeight - y(d.probability))
                        .attr('fill', '#3492eb');

                    // Add labels
                    chart.append('text')
                        .attr('x', chartWidth / 2)
                        .attr('y', chartHeight + margin.bottom - 10)
                        .style('text-anchor', 'middle')
                        .text('States');

                    chart.append('text')
                        .attr('transform', 'rotate(-90)')
                        .attr('y', -margin.left + 20)
                        .attr('x', -chartHeight / 2)
                        .style('text-anchor', 'middle')
                        .text('Probability');

                } else {
                    // Create line chart for continuous/temporal data
                    const data = Object.entries(queryResult.result[variable])
                        .map(([key, value]) => ({ point: key, value: value }));

                    const x = d3.scaleLinear()
                        .domain(d3.extent(data, d => +d.point))
                        .range([0, chartWidth]);

                    const y = d3.scaleLinear()
                        .domain(d3.extent(data, d => +d.value))
                        .range([chartHeight, 0]);

                    // Add X axis
                    chart.append('g')
                        .attr('transform', `translate(0,${chartHeight})`)
                        .call(d3.axisBottom(x));

                    // Add Y axis
                    chart.append('g')
                        .call(d3.axisLeft(y));

                    // Add line
                    const line = d3.line()
                        .x(d => x(+d.point))
                        .y(d => y(+d.value));

                    chart.append('path')
                        .datum(data)
                        .attr('fill', 'none')
                        .attr('stroke', '#3492eb')
                        .attr('stroke-width', 2)
                        .attr('d', line);
                }

                // Add title
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', margin.top / 2)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .text(`${queryType} Query Result for ${variable}`);
            }

            // Create initial visualization
            if (variables.length > 0) {
                createVisualization(variables[0]);
            }

            // Update visualization when variable selection changes
            variableSelect.addEventListener('change', (event) => {
                createVisualization(event.target.value);
            });
        }

        document.getElementById('uploadNetworkForm').addEventListener('submit', uploadNetwork);
        document.getElementById('uploadCPTForm').addEventListener('submit', uploadCPT);

        document.getElementById('queryType').addEventListener('change', function() {
            var timeStepsInput = document.getElementById('timeSteps');
            var queryVarsInput = document.getElementById('queryVars');
            if (this.value === 'temporal') {
                timeStepsInput.style.display = 'block';
            } else {
                timeStepsInput.style.display = 'none';
            }
            if (this.value === 'mpe') {
                queryVarsInput.style.display = 'none';
            } else {
                queryVarsInput.style.display = 'block';
            }
        });

        document.getElementById('queryForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            var queryType = document.getElementById('queryType').value;
            var inferenceAlgorithm = document.getElementById('inferenceAlgorithm').value;
            var queryVars = document.getElementById('queryVars').value.split(',').map(s => s.trim());
            var evidence = JSON.parse(document.getElementById('evidence').value || '{}');
            var interventions = JSON.parse(document.getElementById('interventions').value || '{}');
            var timeSteps = parseInt(document.getElementById('timeSteps').value);

            var data = {
                query_type: queryType,
                inference_algorithm: inferenceAlgorithm,
                query_vars: queryVars,
                evidence: evidence,
                interventions: interventions
            };

            if (queryType === 'temporal') {
                data.time_steps = timeSteps;
            }

            if (queryType === 'mpe') {
                delete data.query_vars;
            }

            try {
                const response = await axios.post('/query', data, {
                    headers: { 'Authorization': 'Bearer ' + apiToken }
                });
                
                // Format and display the query result
                const resultContainer = document.getElementById('queryResult');
                resultContainer.innerHTML = '<h3>Query Result:</h3>';
                
                if (response.data.status === 'success') {
                    const result = response.data.result;
                    const resultDiv = document.createElement('div');
                    resultDiv.innerHTML = '<pre>' + JSON.stringify(result, null, 2) + '</pre>';
                    resultContainer.appendChild(resultDiv);
                    
                    // Add visualization
                    visualizeQueryResult(response.data, data.query_type);
                } else {
                    resultContainer.innerHTML += '<p>Error: ' + response.data.message + '</p>';
                }
            } catch (error) {
                console.error('Error querying network:', error);
                document.getElementById('queryResult').innerHTML = 
                    '<p>Error querying network: ' + error.message + '</p>';
            }
        });

        visualizeNetwork();
    </script>
</body>
</html>